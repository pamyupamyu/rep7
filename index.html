<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">

  <!--
   デフォルトのスタイル
   より見やすく変更しても良い
  -->
  <link rel="stylesheet" href="default.css"/>

  <!--
    SyntaxHighlighter 3.0.83 (http://alexgorbatchev.com/SyntaxHighlighter/)
    Java のコードを読みやすくする
  -->
  <link rel="stylesheet" href="shCore.css"/>
  <link rel="stylesheet" href="shThemeDjango.css"/>
  <script src="shCore.js"></script>
  <script src="shBrushJava.js"></script>
  <script>SyntaxHighlighter.all();</script>

  <!--
    目次を動的に生成する
  -->
  <script src="outliner.js"></script>
  <script>
    window.addEventListener('load', function() {
      // 第一引数: アウトライン対象の要素のセレクタ，第二引数: アウトラインを格納する要素のセレクタ．
      new TOutliner('h2', '#outline');
    });
  </script>

  <title>知能プログラミング演習IIグループ作成 レポート</title>
</head>

<!-- このグループ作成資料は，同じファイルを全員のGrepX（Grep5やGrep6等）ディレクトリにコピーして置くこと -->

<body>
<header>
  <!-- グループ番号を書く．-->
  <h1>グループ1</h1>

  <!-- 目次生成用 -->
  <nav id="outline"></nav>
</header>

<!-- グループ全員の名前, 学籍番号を書き，個人作成書類へのリンクを張る -->
<h2>メンバー</h2>
<ul>
<li><a href="../../../../ckb15068/workspace/kprep/rep7/index.html">島野広大 26115068</a>
<li><a href="../../../../ckb15069/workspace/kprep/rep7/index.html">清水涼太 26115069</a>
<li><a href="../../../../ckb15070/workspace/kprep/rep7/index.html">新海知道 26115070</a>
<li><a href="../../../../ckb15073/workspace/kprep/rep7/index.html">椙田大輔 26115073</a>
<li><a href="../../../../ckb15074/workspace/kprep/rep7/index.html">鈴木健太 26115074</a>
</ul>

<h2>役割分担</h2>
<!-- 役割分担を書く．-->
<ul>
<li>島野広大: 課題7-1担当
<li>清水涼太: 課題7-2担当
<li>新海知道: 課題7-3 & グループレポート担当
<li>椙田大輔: 課題7-1担当
<li>鈴木健太: 課題7-1担当
</ul>

<h2>ソースファイル</h2>
<ul>
  <li><a href="../../../../ckb15070/workspace/Planning/src/Planner.java">Planner.java</a>
</ul>


<h2>課題7-1</h2>
<!-- 課題を書く．-->
目標状態を変えてみたときに，動作が正しくない場合があったかどうか，実行例を示して考察せよ．<br>
また，もしあったならその箇所を修正し，どのように修正したか記せ．

<p>
詳細は担当者のレポート<br>
<a href="../../../../ckb15068/workspace/kprep/rep7/index.html">島野広大</a><br>
<a href="../../../../ckb15073/workspace/kprep/rep7/index.html">椙田大輔</a>
</p>

<h3>独自仕様の説明</h3>
課題に加えて、以下の独自仕様として組み込んだ
<p>
<li>目標状態の順番が、ontable -> ?x on ?y -> clear -> handEmptyになっていなくてはいけない。なので、入力されている目標状態が適切でない時にソートしてくれるgoalsort()メソッドを作成した</li>
</p>

<h3>プログラムの構造</h3>
<pre>
変更前から実装されている部分、及び今回実装した部分の説明を行う
プランニングを行う本体といえるプログラムはクラスPlanner,Operator,Unifierで行う

Plannerクラスに含まれるメソッドを以下に示す

public static void main
メインメソッド
Plannnerを開始するためのメソッド
最初に実行する初期状態設定のフレームを生成する
goalList,initialState等必要な情報をGUIから取得する
次にplanningメソッドを呼び出しプランニングを実行する
この時生成されたプランはgoalList,initialStateと同じく
ベクトル型の変数に格納される
またプランニングが終了したとき得た解法を表示する

public Vector goalsort
独自仕様
ゴールリストの内容をエラーが起こらないように整えるメソッド
"ontable","clear","handEmpty","on"等ごとに分割し
それらを指定の順番でソートしたリストを返す
"on"のソートに関しては下記のXonYsortによってソートされる

public ArrayList XonYsort
独自仕様
上記の"on"の含まれるリストをソートする

private boolean planning
プランニングを実行する
基本的には演繹推論システムの後ろ向き推論と同じである
goalListに含まれている目標をplanningAGoalを用いて
プランニングを実行していく

private int planningAGoal
上記のplanningに必要な
一つのゴールへのプランニングを実行するメソッド
与えられた目標に必要な条件がCurrentStateにあるか否かを
検索しなかった場合は競合解消に基づき副目標を設定する
（課題7-2参照）

private Vector getVars
もともとあるベクトルthe Patternから
変数の有無を示すベクトルvarsを返すメソッド

private boolean var
引数のString型文字列が?から始まる場合
変数扱いとするためのメソッド

private Operator rename
オペレータの変数をリネーミングするメソッド
同じプランニングの過程で例えば?xが二つ出てきた場合に
片方を?x1もう片方を?x2とするために必要である

private Vector initGoalList
ゴールリストを生成するメソッド
今回は使用していない

private Vector initInitialState
同じく

private void initOperators
Place、Pickなどのオペレーターを定義するメソッド
それぞれのオペレーターには名前、
実行に入るためのIFリスト、実行時に追加されるADDリスト
実行時に削除されるDELETEリストが定義されている

Operatorクラスに含まれるメソッドを以下に示す

public Vector getAddList
各オペレーターのADDリストを取得する

public Vector getDeleteList
各オペレーターのDELETEリストを取得する

public Vector getIfList
各オペレーターのIFリストを取得する

public String toString
オペレーターの名前、各リストをString型にするメソッド

public boolean applyStatecheck
独自仕様
下記のapplyStateメソッドが実行可能であるかどうかを確認するメソッドである

public Vector applyState
与えられたtheStateにADDリストを加えて
DELETEリストを削除する動作を行うメソッドである

public Operator getRenamedOperator
オペレータークラスの変数をリネーミングする
リネーミングの方式は前述のrenameメソッドと同様である

private Vector getVars
与えられたthePatternをトークン分割し
それぞれのトークンが変数であるかどうかを確認するメソッドである

private Hashtable makeRenamedVarsTable
上記のgetRenamedOperatorで作成する際リネーミングする前の変数と
した後の変数を対応させたハッシュテーブルを返すメソッドである

private String renameVars
入力thePatternと前述のmakeRenamedVarsTableを基にthePatternをトークン
分解しそこに存在する変数を対応するリネーミングされた変数に置き換えるメソッドである

public Operator instantiate
変数束縛情報であるtheBindingを用いて変数を具体化するメソッドである
そのオペレーターの名前、IFリスト、ADDリスト、DELETEリストに現れる変数を
下記のinstantiateStringメソッドを用いて各変数に対応した値に置き換える

private String instantiateString
上記のinstantiateのを使用するためのメソッドである
与えられたthePatternをトークン分割し各トークンが変数である場合
変数の値をtheBindingから取得し代入する

Unifierクラスに含まれるメソッドを以下に示す

public boolean unify
マッチングを行う核となるメソッドである

boolean tokenMatching
トークン同士の変数の有無ごとにマッチングを返すメソッドである

boolean varMatching
上記のtokenMatchingで変数があった場合のマッチングを行うメソッドである

void replaceBuffer
Bufferの要素と置き換えるメソッドである

void replaceBindings
束縛変数情報Bindingと置き換えるメソッドである

</pre>
<h3>実装の説明</h3>
メソッドplanningAGoalにて現在状態と目標状態とのUnifyが失敗して<br>
誤作動が起こる場合について変更した<br>
applyStateCheckメソッドを追加し更新が可能な場合と不可能な場合に分割する<br>
現在状態にあるものをADDしようとしたとき、もしくは現在状態にないものを<br>
DELETEしようとしたときに不可能な場合と判断される<br>
<br>
<pre class="brush: java">
	public boolean applyStatecheck(Vector theState,Hashtable theBinding){
		Vector checkState= (Vector)theState.clone();
		for(int i = 0 ; i < addList.size() ; i++){
			if(checkState.contains(instantiateString((String)addList.elementAt(i),theBinding)))return false;
		}
		for(int i = 0 ; i < deleteList.size() ; i++){
			if(!checkState.contains(instantiateString((String)deleteList.elementAt(i),theBinding)))return false;
		}
		return true;
	}
</pre>
またこれを実行するためには目標状態の順番が一定である必要がある<br>
これを行うためにgoalsortメソッドを追加した<br>
このソートは基数ソートの要領で目標状態の種類ごとに<br>
ソーティングしているがA on Bのようなonに関するソートのみ<br>
XonYsortを用いている<br>
<pre class="brush: java">
public Vector goalsort(Vector goalList){
        Vector newgoal = new Vector();
        ArrayList ontable = new ArrayList();
        ArrayList xony = new ArrayList();
        ArrayList clear = new ArrayList();
        ArrayList hE = new ArrayList();
        ArrayList poada = new ArrayList();
         
        for(int i = 0; i < goalList.size(); ++i){ //ゴールの内容ごとに分類
            StringTokenizer st = new StringTokenizer((String)goalList.elementAt(i));
            String tmp = st.nextToken();
            if(tmp.equals("ontable")){
                ontable.add((String)goalList.elementAt(i));
                poada.add(st.nextToken());
            }else if(tmp.equals("clear")){
                clear.add((String)goalList.elementAt(i));
            }else if(tmp.equals("handEmpty")){
                hE.add((String)goalList.elementAt(i));
            }else{
                xony.add((String)goalList.elementAt(i));
            }
        }
         
        for(int i = 0; i < ontable.size(); ++i){
            newgoal.add(ontable.get(i));
        }
         
        //System.out.println("before:" + xony);
        xony = XonYsort(xony,poada);
        //System.out.println("after:" + xony);
         
        for(int i = 0; i < xony.size(); ++i){
            newgoal.add(xony.get(i));
        }
        for(int i = 0; i < clear.size(); ++i){
            newgoal.add(clear.get(i));
        }
        for(int i = 0; i < hE.size(); ++i){
            newgoal.add(hE.get(i));
        }
         
        return newgoal;
    }
     
    public ArrayList XonYsort(ArrayList xony,ArrayList poada){
        ArrayList newxony = new ArrayList();
         
        for(int i = 0; i < poada.size(); ++i){
            for(int j = 0; j < xony.size(); ++j){
                 
                StringTokenizer st = new StringTokenizer((String)xony.get(j));
                String X = st.nextToken();
                st.nextToken();
                String Y = st.nextToken();
                if(poada.get(i).equals(Y)){
                    newxony.add((String)xony.get(j));
                    poada.set(i, (String)X);
                    j = -1;
                }
            }
             
        }
         
        return newxony;
    }
</pre>
<br>
<h3>実行例</h3>
コンソール上で実行したものを下記に示す
改善前と異なる点はPlace A on Aや
Place A on B かつ Place C on B など
現実にあり得ない状態を示すことがなくなった
<pre>
Picked up _JAVA_OPTIONS: -XX:+UseSerialGC
*** GOALS ***[ontable C, B on C, A on B, clear A, handEmpty]
**ontable C
[ontable A, ontable B, ontable C, clear A, clear B, clear C, handEmpty]
*** GOALS ***[B on C, A on B, clear A, handEmpty]
**B on C
Place B on C
*** GOALS ***[clear C, holding B]
**clear C
[ontable A, ontable B, ontable C, clear A, clear B, clear C, handEmpty]
*** GOALS ***[holding B]
**holding B
pick up B from the table
*** GOALS ***[ontable B, clear B, handEmpty]
**ontable B
[ontable A, ontable B, ontable C, clear A, clear B, clear C, handEmpty]
*** GOALS ***[clear B, handEmpty]
**clear B
[ontable A, ontable B, ontable C, clear A, clear B, clear C, handEmpty]
*** GOALS ***[handEmpty]
**handEmpty
pick up B from the table
チェックは正常終了した○○○○
[ontable A, ontable C, clear A, clear C, holding B]
Place B on C
チェックは正常終了した○○○○
[ontable A, ontable C, clear A, B on C, clear B, handEmpty]
[ontable A, ontable C, clear A, B on C, clear B, handEmpty]
*** GOALS ***[A on B, clear A, handEmpty]
**A on B
Place A on B
*** GOALS ***[clear B, holding A]
**clear B
[ontable A, ontable C, clear A, B on C, clear B, handEmpty]
*** GOALS ***[holding A]
**holding A
pick up A from the table
*** GOALS ***[ontable A, clear A, handEmpty]
**ontable A
[ontable A, ontable C, clear A, B on C, clear B, handEmpty]
*** GOALS ***[clear A, handEmpty]
**clear A
[ontable A, ontable C, clear A, B on C, clear B, handEmpty]
*** GOALS ***[handEmpty]
**handEmpty
pick up A from the table
チェックは正常終了した○○○○
[ontable C, B on C, clear B, holding A]
Place A on B
チェックは正常終了した○○○○
[ontable C, B on C, A on B, clear A, handEmpty]
[ontable C, B on C, A on B, clear A, handEmpty]
*** GOALS ***[clear A, handEmpty]
**clear A
[ontable C, B on C, A on B, clear A, handEmpty]
*** GOALS ***[handEmpty]
**handEmpty
***** This is a plan! *****
pick up B from the table
Place B on C
pick up A from the table
Place A on B
</pre>

<h2>課題7-2</h2>
<!-- 以下，上記と同様 -->
教科書のプログラムでは，オペレータ間の競合解消戦略としてランダムなオペレータ選択を採用している．<br>
これを，効果的な競合解消戦略に改良すべく考察し，実装せよ．<br>
改良の結果，性能がどの程度向上したかを定量的に（つまり数字で）示すこと．
<p>
詳細は担当者のレポート<br>
<a href="../../../../ckb15069/workspace/kprep/rep7/index.html">清水涼太</a>
</p>


<h3>独自仕様の説明</h3>
課題に加えて、以下の独自仕様として組み込んだ
<p>
<li>CurrentStateの中身と、ゴールを元にオペレーターを選択するメソッド</li>
</p>


<h3>プログラムの構造</h3>
int ConflictResolution<br>
競合解消のために次に選択するオペレーターを確定するメソッド<br>
ddlistのStateとtheGoalの一致する状態をもつオペレータで且つ、Iflistの 状態とCurrentState<br>
の状態でunifyを行いマッチ数をカウントする。 尤もカウントの多いオペレータを現在の状態に<br>
合うオペレータとして、 インデックスを返すメソッド<br>
<br>
<h3>実装の説明</h3>
最初にaddlistのstateとgoalのトークン数を比較し
トークン数、及び種類が一致した場合にIFリストに変数を具体化して格納する
このIFリストとCurrentStateでマッチングを行い回数を保存する
全てのオペレーターにてマッチングを行った後マッチングの回数の最も少ないものを
インデックスとして返す
例外として、theGoalにhandEmptyを渡された場合は、常に何かを持っている状態であるので
最終的な目的状態から"?x on ?y"となっているStateを探し現在持っているものが
?xに対応し且つ、 ?yに対応するモノが"clear ?y"を満たしているならば
"Pleace ?x on ?y"のindexを返すようにしている

<pre class="brush: java">
 int ConflictResolution(String theGoal,Vector theCurrentState){
		String[] goal = theGoal.split(" ",0);
		int[] cost = new int[operators.size()];
		boolean mflag;
		for(int i=0;i< operators.size();++i){
			Operator anOperator = (Operator)operators.elementAt(i);
			Vector addlist = (Vector)anOperator.getAddList();
			Vector iflist = (Vector)anOperator.getIfList();
			Vector addList = new Vector();
			for(int j=0;j< addlist.size();++j){
				addList.addElement(((String)addlist.elementAt(j)));
			}
			Vector ifList = new Vector();
			for(int j=0;j< iflist.size();++j){
				ifList.addElement(((String)iflist.elementAt(j)));
			}
			mflag = false;
			for(int j=0;j< addList.size();++j){
				String[] str = ((String)addList.elementAt(j)).split(" ",0);
				if(str.length==goal.length){
					if(goal.length==3){
						for(int k=0;k< ifList.size();++k){
							String[] s = ((String)ifList.elementAt(k)).split(" ",0);
							if(s[1].equals("?x")){
								s[1] = goal[0];
							}else if(s[1].equals("?y")){
								s[1] = goal[2];
							}
							StringBuffer buf = new StringBuffer();
							buf.append(s[0]);
							for(int l=1;l< s.length;++l)buf.append(" "+s[l]);
							ifList.set(k,buf.toString());
						}
						mflag = true;
					}else if(goal.length==2){
						if(goal[0].equals(str[0])){
							for(int k=0;k< ifList.size();++k){
								String[] s = ((String)ifList.elementAt(k)).split(" ",0);
								if(s.length==3){
									if(str[1].equals("?x")) s[0]=goal[1];
									else s[2] = goal[1];
								}else if(s.length==2){
									if(s[1].equals(str[1])) s[1]=goal[1];
								}
								StringBuffer buf = new StringBuffer();
								buf.append(s[0]);
								for(int l=1;l< s.length;++l)buf.append(" "+s[l]);
								ifList.set(k,buf.toString());
							}
							mflag=true;
						}
					}else if(goal.length==1){mflag=true;}
				}
			}
			Hashtable bind = new Hashtable();
			if(mflag){
				for(int j = 0 ; j < ifList.size() ; ++j){
					int size = theCurrentState.size();
					for(int k=0;k< size;++k){
						String aState = (String)theCurrentState.elementAt(k);
						if((new Unifier()).unify((String)ifList.elementAt(j),aState,bind)){
							cost[i]+=1;
						}
					}
				}
				bind.clear();
			}
		}
		
		int index = 0;
		int max=cost[0];
		for(int i=1;i< cost.length;++i){
			if(cost[i]>=max){
				index = i;
				max = cost[i];
			}
		}
		if(goal[0].equals("handEmpty")){
			String[] hold = ((String)theCurrentState.lastElement()).split(" ",0);
			for(int i=0;i< finalgoal.size();++i){
				String[] fg = ((String)finalgoal.elementAt(i)).split(" ",0);
				if(fg.length==3){
					if(fg[0]==hold[1] && theCurrentState.contains("clear "+fg[2])){
						return index;
					}
				}
			}
			cost[index] -= 5;
			index = 0;
			max=cost[0];
			for(int i=1;i< cost.length;++i){
				if(cost[i]>=max){
					index = i;
					max = cost[i];
				}
			}
		}
		
		return index;
	}
</pre>
<h3>実行例</h3>
実行例は上記の課題7-1と同じなので省略する<br>
<br>
改善前との違いは実行時の正解までへの手数が何度実行しても<br>
変わらないことである<br>
また実行例の場合では最適解を出せているので<br>
改良出来ていると言える<br>
<br>
<h2>課題7-3</h2>
上記7-2で改良したプランニングシステムのGUIを実装せよ．<br>
ブロック操作の過程をグラフィカルに可視化し，初期状態や目標状態をGUI上で変更できることが望ましい．
<p>
詳細は担当者のレポート<br>
<a href="../../../../ckb15074/workspace/kprep/rep7/index.html">鈴木健太</a><br>
<a href="../../../../ckb15074/workspace/kprep/rep7/index.html">新海知道</a>
</p>
<h3>独自仕様の説明</h3>
課題に加えて、以下の独自仕様として組み込んだ
<p>
<li>画像を作成して視覚的に分かりやすくし、、初期状態とゴール状態をボタンによって操作できるようにした。 </li>
<li>作成されたプランは"読み込み実行ボタン"により一回ボタンを押すと1つずつ実行される仕様とした。 </li>
</p>
<h3>プログラムの構造</h3>
<pre>
GUIに関するメソッドはGUIクラス、InitPanelクラス、GoalPanelクラスを作成した
GUIフレームは起動されたときボタン、画像、planningの経過などの文字列を表示するためのフレーム
初期状態フレーム、目標状態フレームはボタン操作によってブロックを動かし
決定ボタンによってそれぞれ初期状態、目標状態を確定させるためのフレームである

以下にこのGUIフレームに含まれる主なメソッドを説明する
match_list
入力matchが現状を表すArrayListのstateの中にあるかどうかを確かめるメソッド

debug
現状を表すArrayListのstateの中身を表示するためのメソッド
本実装には用いていないが、その名の通りデバック時に多用していた

stack
ブロックを別のブロックの上に積み上げる動作を行うためのメソッドである
例えばholding X かつclear Yな状態を確認してその状態が成立する場合
Yの上にXを置くといった仕様にしている

pick
ブロックをつかむ動作を行うためのメソッドである
プランニング実行時と異なるのはremoveもまとめてpickに含まれている所である
例えばhandEmpty かつ clear X であるなら
Xをつかむといった仕様にしている

put
ブロックをテーブルに置く動作を行うためのメソッドである
例えばholding Xであるなら
Xをテーブルの上に置くといった仕様にしている

play
planningで実行された結果を文字列として読み取りそれぞれに
対応した動作を行うメソッドである

initread
初期設定GUIで設定した初期状態を読み込み本GUIに
組み込むためのメソッドである
初期状態をArrayListのstateとしstateによる初期状態
にあったような見た目に変更している

初期状態フレーム、及び目標状態フレームは
上記の動作用メソッドをそれぞれのボタンに割り振っている
だけなのでメソッドの説明については省略する

</pre>
<h3>実装の説明</h3>
 実装したプログラムに関して、GUIクラス、InitPanelクラス、GoalPanelクラスを中心に説明する。<br>
<br>
まずGUIクラスについてである。<br>
GUIの実装部分の説明を行う<br>
まずGUIに必要な画像を別途ペイントソフトで製作する<br>
次にブロックの画像の座標を取得しプランニングの動作に合わせて<br>
ブロックの位置を調整していく<br>
これをそれぞれpick,put,stackに適応させることによって<br>
実際にブロックを動かしているかのようなGUIを作成することができた<br>
planning実行結果を読み取る部分は非常にシンプルでplanning以下の<br>
文章をそのままif文分岐で利用し文章ごとの動作を行っている<br>
<br>
次にGUIフレーム以外の変更点を説明する<br>
Plannerのstartを変更して、作成されたplanを返り値として返す仕様とその値をplanlistに格納している。<br>
playボタンが読み込み実行ボタンであり、与えられたplanlistを一行ずつ読み込んで画面に反映するものである。<br>
読み込み実行ボタンが一回押された場合、planlistの中身をcountを使ってひとつ取得して、それをplayメソッドで実行して画面に反映、またtextとしても取得して、そのtextを画面に表示する。<br>
initread()メソッドについて<br>
initread()メソッドでは設定された初期状態を読み込む。<br>
ArrayList型のstateに"ontable A"や"B on A"などの状態が格納されているので、それをfor文でstateの要素をひとつずつ読み込み、"ontable A"あれば、Aを地面に設置するのを座標指定で行う。<br>
すべての条件に対して、条件に合うような座表指定をすることで画面に条件に合う状態を表現した。<br>
<br>
GUIフレームのソースコードを以下に示す<br>
<pre class="brush: java">
  class GUI extends JFrame implements ActionListener{
    String sample[] = new String[10];
    //追加
    ArrayList< String> planlist = (new Planner()).start();
    //追加終了
    static ArrayList< String> state = new ArrayList< String>();
    static ArrayList< String> goal = new ArrayList< String>();
    String enter1 = "";
    //ボタンを押すとA,B,Cが入る
    String enter2 = "";
    String sample_text="";
    //JTextField text = new JTextField("無実装");
    Button put = new Button("下す");
    Button pick = new Button("掴む");
    Button stack = new Button("積む");
    Button a_button = new Button("A");
    Button b_button = new Button("B");
    Button c_button = new Button("C");
    Button play = new Button("読込実行");
    ImageIcon back = new ImageIcon("./back.png");
    ImageIcon human = new ImageIcon("./human.png");
    ImageIcon icon1 = new ImageIcon("./block_a.png");
    ImageIcon icon2 = new ImageIcon("./block_b.png");
    ImageIcon icon3 = new ImageIcon("./block_c.png");
    JLabel back_label = new JLabel(back);
    JLabel chara_label = new JLabel(human);
    JLabel label1 = new JLabel(icon1);
    JLabel label2 = new JLabel(icon2);
    JLabel label3 = new JLabel(icon3);
    JLabel explain = new JLabel();
    JLabel mode = new JLabel();
    JPanel p = new JPanel();
 
 
    //ブロックのそれぞれの初期位置
    int ax=48,ay=240;
    int bx=144,by=240;
    int cx=240,cy=240;
    int ux=0,uy=192;
    int count =0;
 
    GUI(String title){
        setTitle(title);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        //p.setVisible(false);
        initread();
        setLocation(100, 100); //表示位置
        setSize(384, 412); //表示サイズ
        setResizable(false); //リサイズの禁止
 
        //初期状態
        //state.add("ontable A");
        //state.add("ontable B");
        //state.add("ontable C");
        //state.add("clear A");
        //state.add("clear B");
        //state.add("clear C");
        //state.add("handEmpty");
 
        //ボタン、ラベルなどの座標決定
        p.setLayout(null);
        chara_label.setBounds(ux,uy,48,96);
        back_label.setBounds(0,0,384,384);
        explain.setForeground(Color.WHITE);
        //explain.setBackground(Color.WHITE);
        explain.setFont(new Font("ＭＳ ゴシック", Font.BOLD, 20));
        //explain.setOpaque(true);
        explain.setBounds(5,10,320,20);
        //text.setBounds(20,40,320,30);
         
        mode.setForeground(Color.YELLOW);
        mode.setFont(new Font("ＭＳ ゴシック",Font.BOLD,20));
        mode.setBounds(5,50,320,20);
        mode.setText("プランニング実行");
 
        put.addActionListener(this);
        put.setBounds(308, 190 , 56, 30);
        pick.addActionListener(this);
        pick.setBounds(308, 230 , 56, 30);
        stack.addActionListener(this);
        stack.setBounds(308, 270 , 56, 30);
        play.addActionListener(this);
        play.setBounds(260, 310 , 110, 60);
        a_button.addActionListener(this);
        a_button.setBounds(308, 160 , 17, 15);
        b_button.addActionListener(this);
        b_button.setBounds(327, 160 , 17, 15);
        c_button.addActionListener(this);
        c_button.setBounds(346, 160 , 17, 15);
 
        //貼り付け
        //p.add(put);
        //p.add(pick);
        //p.add(stack);
        p.add(play);
        //p.add(a_button);
        //p.add(b_button);
        //p.add(c_button);
        p.add(explain);
        p.add(mode);
        //p.add(text);
        p.add(label1);
        p.add(label2);
        p.add(label3);
        p.add(chara_label);
        p.add(back_label); //下のが背景側に来る描画順に注意
 
        sample[0]="pick up B from the table";
        sample[1]="Place B on A";
        sample[2]="remove B from on top A";
        sample[3]="Place B on C";
        sample[4]="pick up A from the table";
        sample[5]="Place A on A";
        sample[6]="remove A from on top A";
        sample[7]="Place A on A";
        sample[8]="remove A from on top A";
        sample[9]="Place A on B";
 
        Container contentPane = getContentPane();
        contentPane.add(p, BorderLayout.CENTER);
    }
 
    //ボタン操作受付
 
    public void actionPerformed(ActionEvent ae) {
        //enter1 =text.getText();
        if(ae.getSource() == put){
            put();
        }else if(ae.getSource() == pick){
            pick(enter2);
        }else if(ae.getSource() == stack){
            stack(enter2);
        }else if(ae.getSource() == a_button){
            enter2 = "A";
        }else if(ae.getSource() == b_button){
            enter2 = "B";
        }else if(ae.getSource() == c_button){
            enter2 = "C";
        }else if(ae.getSource() == play){
            if(count< planlist.size()){
                //変更
                play(planlist.get(count));
                sample_text=planlist.get(count);
                explain.setText(sample_text);
                count++;
            }
        }
    }
 
    //Listの中にString matchがあるときtrueを返す
    boolean match_list(ArrayList state,String match){
        boolean C=false;
        for(int i=0;i< state.size();i++){
            Object temp = state.get(i);
            String str = temp.toString();
            if(str.equals(match)){
                //System.out.println("OK");
                C =true;
            }
        }
        return C;
    }
 
    //Listの中身の全表示
    void debug(ArrayList state){
        for(int i=0;i< state.size();i++){
            Object str = state.get(i);
            String temp = str.toString();
            System.out.println(temp);
        }
    }
 
    //clearなブロックに今持っている(holdingしている)ブロックを置く
    //clearなブロックは引数blockとして選択する
 
    void stack(String block){
        if(block.equals("A")){
            if(match_list(state,"clear A")&&match_list(state,"holding B")){
                ux=ax-48;
                bx=ax;
                by=ay-48;
                state.remove(state.indexOf("clear A"));
                state.remove(state.indexOf("holding B"));
                state.add("B on A");
                state.add("handEmpty");
                label2.setBounds(bx,by,48,48);
                p.add(label2);
                chara_label.setBounds(ux,uy,48,96);
                p.add(chara_label);
                p.add(back_label);
                //debug(state);
            }else if(match_list(state,"clear A")&&match_list(state,"holding C")){
                ux=ax-48;
                cx=ax;
                cy=ay-48;
                state.remove(state.indexOf("clear A"));
                state.remove(state.indexOf("holding C"));
                state.add("C on A");
                state.add("handEmpty");
                label3.setBounds(cx,cy,48,48);
                p.add(label3);
                chara_label.setBounds(ux,uy,48,96);
                p.add(chara_label);
                p.add(back_label);
                //debug(state);
            }
        }else if(block.equals("B")){
            if(match_list(state,"clear B")&&match_list(state,"holding A")){
                ux=bx-48;
                ax=bx;
                ay=by-48;
                state.remove(state.indexOf("clear B"));
                state.remove(state.indexOf("holding A"));
                state.add("A on B");
                state.add("handEmpty");
                label1.setBounds(ax,ay,48,48);
                p.add(label1);
                chara_label.setBounds(ux,uy,48,96);
                p.add(chara_label);
                p.add(back_label);
                //debug(state);
            }else if(match_list(state,"clear B")&&match_list(state,"holding C")){
                ux=bx-48;
                cx=bx;
                cy=by-48;
                state.remove(state.indexOf("clear B"));
                state.remove(state.indexOf("holding C"));
                state.add("C on B");
                state.add("handEmpty");
                label3.setBounds(cx,cy,48,48);
                p.add(label3);
                chara_label.setBounds(ux,uy,48,96);
                p.add(chara_label);
                p.add(back_label);
                //debug(state);
            }
 
        }else if(block.equals("C")){
            if(match_list(state,"clear C")&&match_list(state,"holding A")){
                ux=cx-48;
                ax=cx;
                ay=cy-48;
                state.remove(state.indexOf("clear C"));
                state.remove(state.indexOf("holding A"));
                state.add("A on C");
                state.add("handEmpty");
                label1.setBounds(ax,ay,48,48);
                p.add(label1);
                chara_label.setBounds(ux,uy,48,96);
                p.add(chara_label);
                p.add(back_label);
                //debug(state);
            }else if(match_list(state,"clear C")&&match_list(state,"holding B")){
                ux=cx-48;
                bx=cx;
                by=cy-48;
                state.remove(state.indexOf("clear C"));
                state.remove(state.indexOf("holding B"));
                state.add("B on C");
                state.add("handEmpty");
                label2.setBounds(bx,by,48,48);
                p.add(label2);
                chara_label.setBounds(ux,uy,48,96);
                p.add(chara_label);
                p.add(back_label);
                //debug(state);
            }
        }
    }
    //ontableにあるclearなブロックを持つ
    //同じく持つブロックは選択
    void pick(String block){
        if(block.equals("A")){
            if(match_list(state,"clear A")&&match_list(state,"handEmpty")){
                ux=ax-48;
                ax=25;
                ay=316;
                state.remove(state.indexOf("handEmpty"));
                state.add("holding A");
                if(match_list(state,"ontable A")){
                    state.remove(state.indexOf("ontable A"));
                }else if(match_list(state,"A on B")){
                    state.remove(state.indexOf("A on B"));
                    state.add("clear B");
                }else if(match_list(state,"A on C")){
                    state.remove(state.indexOf("A on C"));
                    state.add("clear C");
                }
                label1.setBounds(ax,ay,48,48);
                p.add(label1);
                chara_label.setBounds(ux,uy,48,96);
                p.add(chara_label);
                p.add(back_label);
                //debug(state);
            }
        }else if(block.equals("B")){
            if(match_list(state,"clear B")&&match_list(state,"handEmpty")){
                ux=bx-48;
                bx=25;
                by=316;
                state.remove(state.indexOf("handEmpty"));
                state.add("holding B");
                if(match_list(state,"ontable B")){
                    state.remove(state.indexOf("ontable B"));
                }else if(match_list(state,"B on A")){
                    state.remove(state.indexOf("B on A"));
                    state.add("clear A");
                }else if(match_list(state,"B on C")){
                    state.remove(state.indexOf("B on C"));
                    state.add("clear C");
                }
                label2.setBounds(bx,by,48,48);
                p.add(label2);
                chara_label.setBounds(ux,uy,48,96);
                p.add(chara_label);
                p.add(back_label);
            //debug(state);
            }
        }else if(block.equals("C")){
            if(match_list(state,"clear C")&&match_list(state,"handEmpty")){
                ux=cx-48;
                cx=25;
                cy=316;
                state.remove(state.indexOf("handEmpty"));
                state.add("holding C");
                if(match_list(state,"ontable C")){
                    state.remove(state.indexOf("ontable C"));
                }else if(match_list(state,"C on A")){
                    state.remove(state.indexOf("C on A"));
                    state.add("clear A");
                }else if(match_list(state,"C on B")){
                    state.remove(state.indexOf("C on B"));
                    state.add("clear B");
                }
                label3.setBounds(cx,cy,48,48);
                p.add(label3);
                chara_label.setBounds(ux,uy,48,96);
                p.add(chara_label);
                p.add(back_label);
                //debug(state);
            }
        }
    }
 
    //持っているブロックをtableに置く
    void put(){
        if(match_list(state,"holding A")){
            ax=48;
            ay=240;
            state.remove(state.indexOf("holding A"));
            state.add("ontable A");
            state.add("handEmpty");
            label1.setBounds(ax,ay,48,48);
            p.add(label1);
            chara_label.setBounds(0,192,48,96);
            p.add(chara_label);
            p.add(back_label);
            //debug(state);
        }else if(match_list(state,"holding B")){
            bx=144;
            by=240;
            state.remove(state.indexOf("holding B"));
            state.add("ontable B");
            state.add("handEmpty");
            label2.setBounds(bx,by,48,48);
            p.add(label2);
            chara_label.setBounds(96,192,48,96);
            p.add(chara_label);
            p.add(back_label);
            //debug(state);
        }else if(match_list(state,"holding C")){
            cx=240;
            cy=240;
            state.remove(state.indexOf("holding C"));
            state.add("ontable C");
            state.add("handEmpty");
 
            label3.setBounds(cx,cy,48,48);
            p.add(label3);
            chara_label.setBounds(192,192,48,96);
            p.add(chara_label);
            p.add(back_label);
            //debug(state);
        }
    }
 
    void play(String sample){
        if(sample.equals("pick up A from the table")||sample.equals("remove A from on top B")||sample.equals("remove A from on top C")){
            pick("A");
        }else if(sample.equals("pick up B from the table")||sample.equals("remove B from on top A")||sample.equals("remove B from on top C")){
            pick("B");
        }else if(sample.equals("pick up C from the table")||sample.equals("remove C from on top A")||sample.equals("remove C from on top B")){
            pick("C");
        }else if(sample.equals("Place B on A")||sample.equals("Place C on A")){
            stack("A");
        }else if(sample.equals("Place A on B")||sample.equals("Place C on B")){
            stack("B");
        }else if(sample.equals("Place A on C")||sample.equals("Place B on C")){
            stack("C");
        }else if(sample.equals("put A down on the table") || sample.equals("put B down on the table") || sample.equals("put C down on the table")){
            put();
            }
    }
 
 
 
    /* 追加
     * 初期状態を読み込む
     */
 
    void initread(){
        for(int i = 0; i < state.size(); i++){
            //System.out.println("**********"+state.get(i)+"************");
            if(state.get(i).equals("ontable A")){
                ax = 48;
                ay = 240;
                //label1.setBounds(ax,ay,48,48);
            }
            else if(state.get(i).equals("ontable B")){
                bx = 144;
                by = 240;
                //label2.setBounds(bx,by,48,48);
            }
 
            else if(state.get(i).equals("ontable C")){
                cx = 240;
                cy = 240;
                //label3.setBounds(cx,cy,48,48);
            }
            else if(state.get(i).equals("holding A")){
                ax = 25;
                ay = 316;
                //label1.setBounds(25,316,48,48);
            }
 
            else if(state.get(i).equals("holding B")){
                bx = 25;
                by = 316;
                //label2.setBounds(25,316,48,48);
            }
 
            else if(state.get(i).equals("holding C")){
                cx = 25;
                cy = 316;
                //label3.setBounds(25,316,48,48);
            }
 
            else if(state.get(i).equals("B on A")){
                bx = ax;
                by = ay - 48;
                //label2.setBounds(bx,by,48,48);
            }
 
            else if(state.get(i).equals("C on A")){
                cx = ax;
                cy = ay - 48;
                //label3.setBounds(cx,cy,48,48);
            }
 
            else if(state.get(i).equals("A on B")){
                ax = bx;
                ay = by - 48;
                //label1.setBounds(ax,ay,48,48);
            }
 
            else if(state.get(i).equals("C on B")){
                cx = bx;
                cy = by - 48;
                //label3.setBounds(cx,cy,48,48);
            }
 
            else if(state.get(i).equals("A on C")){
                ax = cx;
                ay = cy - 48;
                //label1.setBounds(ax,ay,48,48);
            }
            else if(state.get(i).equals("B on C")){
                bx = cx;
                by = cy - 48;
                //label1.setBounds(bx,by,48,48);
            }
        }
        label1.setBounds(ax,ay,48,48);
        label2.setBounds(bx,by,48,48);
        label3.setBounds(cx,cy,48,48);
 
    }
}
</pre> 

初期状態フレームのソースコードを以下に示す<br>
<pre class="brush: java">
class InitPanel extends JFrame implements ActionListener {
    String text = "";
    Button ok = new Button("完了");
    Button put = new Button("下す");
    Button pick = new Button("掴む");
    Button stack = new Button("積む");
    Button a_button = new Button("A");
    Button b_button = new Button("B");
    Button c_button = new Button("C");
    ImageIcon icon1 = new ImageIcon("./block_a.png");
    ImageIcon icon2 = new ImageIcon("./block_b.png");
    ImageIcon icon3 = new ImageIcon("./block_c.png");
    ImageIcon back = new ImageIcon("./back.png");
    JLabel label1 = new JLabel(icon1);
    JLabel label2 = new JLabel(icon2);
    JLabel label3 = new JLabel(icon3);
    JLabel back_label = new JLabel(back);
    JPanel p2 = new JPanel();
    JLabel mode = new JLabel();
 
    GUI frame;
    GoalPanel gframe;
    //ArrayList< String> state = new ArrayList< String>();
    String enter2 = "";
 
    //ブロックのそれぞれの初期位置
    int ax=48,ay=240;
    int bx=144,by=240;
    int cx=240,cy=240;
    int count =0;
 
    public InitPanel(String title){
        setTitle(title);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
 
 
        //初期状態
        frame.state.add("ontable A");  
        frame.state.add("ontable B");
        frame.state.add("ontable C");
        frame.state.add("clear A");
        frame.state.add("clear B");
        frame.state.add("clear C");
        frame.state.add("handEmpty");
 
        p2.setLayout(null);
        label1.setBounds(ax,ay,48,48);
        label2.setBounds(bx,by,48,48);
        label3.setBounds(cx,cy,48,48);
        back_label.setBounds(0,0,384,384);
 
        mode.setForeground(Color.YELLOW);
        mode.setFont(new Font("ＭＳ ゴシック",Font.BOLD,20));
        mode.setBounds(5,50,320,20);
        mode.setText("初期状態を設定してください");
 
        // リスナーを登録
        MyMouseListener listener1 = new MyMouseListener(label1);
        MyMouseListener listener2 = new MyMouseListener(label2);
        MyMouseListener listener3 = new MyMouseListener(label3);
 
        /*
        label1.addMouseListener(listener1);
        label1.addMouseMotionListener(listener1);
        label2.addMouseListener(listener2);
        label2.addMouseMotionListener(listener2);
        label3.addMouseListener(listener3);
        label3.addMouseMotionListener(listener3);
*/
 
        ok.addActionListener(this);
        ok.setBounds(240,310,100,50);
        put.addActionListener(this);
        put.setBounds(308, 190 , 56, 30);
        pick.addActionListener(this);
        pick.setBounds(308, 230 , 56, 30);
        stack.addActionListener(this);
        stack.setBounds(308, 270 , 56, 30);
        a_button.addActionListener(this);
        a_button.setBounds(308, 160 , 17, 15);
        b_button.addActionListener(this);
        b_button.setBounds(327, 160 , 17, 15);
        c_button.addActionListener(this);
        c_button.setBounds(346, 160 , 17, 15);
 
        //設置
        p2.add(ok);
        p2.add(put);
        p2.add(pick);
        p2.add(stack);
        p2.add(a_button);
        p2.add(b_button);
        p2.add(c_button);
        p2.add(mode);
        p2.add(label1);
        p2.add(label2);
        p2.add(label3);
        p2.add(back_label);
 
        Container contentPane = getContentPane();
        contentPane.add(p2, BorderLayout.CENTER);
    }
 
 
 
    @Override
    public void actionPerformed(ActionEvent e) {
        // TODO Auto-generated method stub
 
        if(e.getSource() == put){
            put();
        }else if(e.getSource() == pick){
            pick(enter2);
        }else if(e.getSource() == stack){
            stack(enter2);
        }else if(e.getSource() == a_button){
            enter2 = "A";
        }else if(e.getSource() == b_button){
            enter2 = "B";
        }else if(e.getSource() == c_button){
            enter2 = "C";
        }else if(e.getSource() == ok){
            //System.exit(0);
            gframe = new GoalPanel("ゴール状態変更");
            gframe.setVisible(true);
            setVisible(false);
            //frame.p.setVisible(true);
 
        }
    }
 
    boolean match_list(ArrayList state,String match){
        boolean C=false;
        for(int i=0;i< state.size();i++){
            Object temp = state.get(i);
            String str = temp.toString();
            if(str.equals(match)){
                //System.out.println("OK");
                C =true;
            }
        }
        return C;
    }
    //clearなブロックに今持っている(holdingしている)ブロックを置く
    //clearなブロックは引数blockとして選択する
    void stack(String block){
        if(block.equals("A")){
            if(match_list(frame.state,"clear A")&&match_list(frame.state,"holding B")){
                bx=ax;
                by=ay-48;
                frame.state.remove(frame.state.indexOf("clear A"));
                frame.state.remove(frame.state.indexOf("holding B"));
                frame.state.add("B on A");
                frame.state.add("handEmpty");
                label2.setBounds(bx,by,48,48);
                p2.add(label2);
                p2.add(back_label);
                //debug(state);
            }else if(match_list(frame.state,"clear A")&&match_list(frame.state,"holding C")){
                cx=ax;
                cy=ay-48;
                frame.state.remove(frame.state.indexOf("clear A"));
                frame.state.remove(frame.state.indexOf("holding C"));
                frame.state.add("C on A");
                frame.state.add("handEmpty");
                label3.setBounds(cx,cy,48,48);
                p2.add(label3);
                p2.add(back_label);
                //debug(state);
            }
        }else if(block.equals("B")){
            if(match_list(frame.state,"clear B")&&match_list(frame.state,"holding A")){
                ax=bx;
                ay=by-48;
                frame.state.remove(frame.state.indexOf("clear B"));
                frame.state.remove(frame.state.indexOf("holding A"));
                frame.state.add("A on B");
                frame.state.add("handEmpty");
                label1.setBounds(ax,ay,48,48);
                p2.add(label1);
                p2.add(back_label);
                //debug(state);
            }else if(match_list(frame.state,"clear B")&&match_list(frame.state,"holding C")){
                cx=bx;
                cy=by-48;
                frame.state.remove(frame.state.indexOf("clear B"));
                frame.state.remove(frame.state.indexOf("holding C"));
                frame.state.add("C on B");
                frame.state.add("handEmpty");
                label3.setBounds(cx,cy,48,48);
                p2.add(label3);
                p2.add(back_label);
                //debug(state);
            }
        }else if(block.equals("C")){
            if(match_list(frame.state,"clear C")&&match_list(frame.state,"holding A")){
                ax=cx;
                ay=cy-48;
                frame.state.remove(frame.state.indexOf("clear C"));
                frame.state.remove(frame.state.indexOf("holding A"));
                frame.state.add("A on C");
                frame.state.add("handEmpty");
                label1.setBounds(ax,ay,48,48);
                p2.add(label1);
                p2.add(back_label);
                //debug(state);
            }else if(match_list(frame.state,"clear C")&&match_list(frame.state,"holding B")){
                bx=cx;
                by=cy-48;
                frame.state.remove(frame.state.indexOf("clear C"));
                frame.state.remove(frame.state.indexOf("holding B"));
                frame.state.add("B on C");
                frame.state.add("handEmpty");
                label2.setBounds(bx,by,48,48);
                p2.add(label2);
                p2.add(back_label);
                //debug(state);
            }
        }
    }
 
    //clearなブロックを持つ
    //同じく持つブロックは選択
    void pick(String block){
        if(block.equals("A")){
            if(match_list(frame.state,"clear A")&&match_list(frame.state,"handEmpty")){
                ax=25;
                ay=316;
                frame.state.remove(frame.state.indexOf("handEmpty"));
                frame.state.add("holding A");
                if(match_list(frame.state,"ontable A")){
                    frame.state.remove(frame.state.indexOf("ontable A"));
                }else if(match_list(frame.state,"A on B")){
                    frame.state.remove(frame.state.indexOf("A on B"));
                    frame.state.add("clear B");
                }else if(match_list(frame.state,"A on C")){
                    frame.state.remove(frame.state.indexOf("A on C"));
                    frame.state.add("clear C");
                }
                label1.setBounds(ax,ay,48,48);
                p2.add(label1);
                p2.add(back_label);
                //debug(state);
            }
 
        }else if(block.equals("B")){
            if(match_list(frame.state,"clear B")&&match_list(frame.state,"handEmpty")){
                bx=25;
                by=316;
                frame.state.remove(frame.state.indexOf("handEmpty"));
                frame.state.add("holding B");
                if(match_list(frame.state,"ontable B")){
                    frame.state.remove(frame.state.indexOf("ontable B"));
                }else if(match_list(frame.state,"B on A")){
                    frame.state.remove(frame.state.indexOf("B on A"));
                    frame.state.add("clear A");
                }else if(match_list(frame.state,"B on C")){
                    frame.state.remove(frame.state.indexOf("B on C"));
                    frame.state.add("clear C");
                }
                label2.setBounds(bx,by,48,48);
                p2.add(label2);
                p2.add(back_label);
                //debug(state);
            }
        }else if(block.equals("C")){
            if(match_list(frame.state,"clear C")&&match_list(frame.state,"handEmpty")){
                cx=25;
                cy=316;
                frame.state.remove(frame.state.indexOf("handEmpty"));
                frame.state.add("holding C");
                if(match_list(frame.state,"ontable C")){
                    frame.state.remove(frame.state.indexOf("ontable C"));
                }else if(match_list(frame.state,"C on A")){
                    frame.state.remove(frame.state.indexOf("C on A"));
                    frame.state.add("clear A");
                }else if(match_list(frame.state,"C on B")){
                    frame.state.remove(frame.state.indexOf("C on B"));
                    frame.state.add("clear B");
                }
                label3.setBounds(cx,cy,48,48);
                p2.add(label3);
                p2.add(back_label);
                //debug(state);
            }
        }
    }
    //持っているブロックをtableに置く
    void put(){
        if(match_list(frame.state,"holding A")){
            ax=48;
            ay=240;
            frame.state.remove(frame.state.indexOf("holding A"));
            frame.state.add("ontable A");
            frame.state.add("handEmpty");
            label1.setBounds(ax,ay,48,48);
            p2.add(label1);
            p2.add(back_label);
            //debug(state);
        }else if(match_list(frame.state,"holding B")){
            bx=144;
            by=240;
            frame.state.remove(frame.state.indexOf("holding B"));
            frame.state.add("ontable B");
            frame.state.add("handEmpty");
            label2.setBounds(bx,by,48,48);
            p2.add(label2);
            p2.add(back_label);
            //debug(state);
        }else if(match_list(frame.state,"holding C")){
            cx=240;
            cy=240;
            frame.state.remove(frame.state.indexOf("holding C"));
            frame.state.add("ontable C");
            frame.state.add("handEmpty");
            label3.setBounds(cx,cy,48,48);
            p2.add(label3);
            p2.add(back_label);
            //debug(state);
        }
    }
 
}
</pre> 
目標状態フレームのソースコードを以下に示す<br>
<pre class="brush: java">
public GoalPanel(String title){
        setTitle(title);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocation(100, 100); //表示位置
        setSize(384, 412); //表示サイズ
        setResizable(false); //リサイズの禁止
        //初期状態
        goal.add("ontable C");
        goal.add("B on C");
        goal.add("A on B");
        goal.add("clear A");
        goal.add("handEmpty");
         
        goalread();
         
        p3.setLayout(null);
        label1.setBounds(ax,ay,48,48);
        label2.setBounds(bx,by,48,48);
        label3.setBounds(cx,cy,48,48);
        back_label.setBounds(0,0,384,384);
        mode.setForeground(Color.YELLOW);
        mode.setFont(new Font("ＭＳ ゴシック",Font.BOLD,20));
        mode.setBounds(5,50,320,20);
        mode.setText("ゴール目標を設定してください");
        /*
        // リスナーを登録
        MyMouseListener listener1 = new MyMouseListener(label1);
        MyMouseListener listener2 = new MyMouseListener(label2);
        MyMouseListener listener3 = new MyMouseListener(label3);
        label1.addMouseListener(listener1);
        label1.addMouseMotionListener(listener1);
        label2.addMouseListener(listener2);
        label2.addMouseMotionListener(listener2);
        label3.addMouseListener(listener3);
        label3.addMouseMotionListener(listener3);
        */
        ok.addActionListener(this);
        ok.setBounds(240,310,100,50);
        put.addActionListener(this);
        put.setBounds(308, 190 , 56, 30);
        pick.addActionListener(this);
        pick.setBounds(308, 230 , 56, 30);
        stack.addActionListener(this);
        stack.setBounds(308, 270 , 56, 30);
        a_button.addActionListener(this);
        a_button.setBounds(308, 160 , 17, 15);
        b_button.addActionListener(this);
        b_button.setBounds(327, 160 , 17, 15);
        c_button.addActionListener(this);
        c_button.setBounds(346, 160 , 17, 15);
 
        //設置
        p3.add(ok);
        p3.add(put);
        p3.add(pick);
        p3.add(stack);
        p3.add(a_button);
        p3.add(b_button);
        p3.add(c_button);
        p3.add(mode);
        p3.add(label1);
        p3.add(label2);
        p3.add(label3);
        p3.add(back_label);
 
        Container contentPane = getContentPane();
        contentPane.add(p3, BorderLayout.CENTER);
    }
 
 
 
    @Override
    public void actionPerformed(ActionEvent e) {
        // TODO Auto-generated method stub
        if(e.getSource() == put){
            put();
        }else if(e.getSource() == pick){
            pick(enter2);
        }else if(e.getSource() == stack){
            stack(enter2);
        }else if(e.getSource() == a_button){
            enter2 = "A";
        }else if(e.getSource() == b_button){
            enter2 = "B";
        }else if(e.getSource() == c_button){
            enter2 = "C";
        }else if(e.getSource() == ok){
            //System.exit(0);
            frame = new GUI("メイン");
            frame.setVisible(true);
            setVisible(false);
            //frame.p.setVisible(true);
 
        }
    }
 
    boolean match_list(ArrayList state,String match){
        boolean C=false;
        for(int i=0;i<　state.size();i++){
            Object temp = state.get(i);
            String str = temp.toString();
            if(str.equals(match)){
                //System.out.println("OK");
                C =true;
            }
        }
        return C;
    }
    //clearなブロックに今持っている(holdingしている)ブロックを置く
    //clearなブロックは引数blockとして選択する
    void stack(String block){
        if(block.equals("A")){
            if(match_list(goal,"clear A")&&match_list(goal,"holding B")){
                bx=ax;
                by=ay-48;
                goal.remove(goal.indexOf("clear A"));
                goal.remove(goal.indexOf("holding B"));
                goal.add("B on A");
                goal.add("handEmpty");
                label2.setBounds(bx,by,48,48);
                p3.add(label2);
                p3.add(back_label);
                //debug(state);
            }else if(match_list(goal,"clear A")&&match_list(goal,"holding C")){
                cx=ax;
                cy=ay-48;
                goal.remove(goal.indexOf("clear A"));
                goal.remove(goal.indexOf("holding C"));
                goal.add("C on A");
                goal.add("handEmpty");
                label3.setBounds(cx,cy,48,48);
                p3.add(label3);
                p3.add(back_label);
                //debug(state);
            }
        }else if(block.equals("B")){
            if(match_list(goal,"clear B")&&match_list(goal,"holding A")){
                ax=bx;
                ay=by-48;
                goal.remove(goal.indexOf("clear B"));
                goal.remove(goal.indexOf("holding A"));
                goal.add("A on B");
                goal.add("handEmpty");
                label1.setBounds(ax,ay,48,48);
                p3.add(label1);
                p3.add(back_label);
                //debug(state);
            }else if(match_list(goal,"clear B")&&match_list(goal,"holding C")){
                cx=bx;
                cy=by-48;
                goal.remove(goal.indexOf("clear B"));
                goal.remove(goal.indexOf("holding C"));
                goal.add("C on B");
                goal.add("handEmpty");
                label3.setBounds(cx,cy,48,48);
                p3.add(label3);
                p3.add(back_label);
                //debug(state);
            }
 
        }else if(block.equals("C")){
            if(match_list(goal,"clear C")&&match_list(goal,"holding A")){
                ax=cx;
                ay=cy-48;
                goal.remove(goal.indexOf("clear C"));
                goal.remove(goal.indexOf("holding A"));
                goal.add("A on C");
                goal.add("handEmpty");
                label1.setBounds(ax,ay,48,48);
                p3.add(label1);
                p3.add(back_label);
                //debug(state);
            }else if(match_list(goal,"clear C")&&match_list(goal,"holding B")){
                bx=cx;
                by=cy-48;
                goal.remove(goal.indexOf("clear C"));
                goal.remove(goal.indexOf("holding B"));
                goal.add("B on C");
                goal.add("handEmpty");
                label2.setBounds(bx,by,48,48);
                p3.add(label2);
                p3.add(back_label);
                //debug(state);
            }
        }
    }
 
    //ontableにあるclearなブロックを持つ
    //同じく持つブロックは選択
    void pick(String block){
        if(block.equals("A")){
            if(match_list(goal,"clear A")&&match_list(goal,"handEmpty")){
                ax=25;
                ay=316;
                goal.remove(goal.indexOf("handEmpty"));
                goal.add("holding A");
                if(match_list(goal,"ontable A")){
                    goal.remove(goal.indexOf("ontable A"));
                }else if(match_list(goal,"A on B")){
                    goal.remove(goal.indexOf("A on B"));
                    goal.add("clear B");
                }else if(match_list(goal,"A on C")){
                    goal.remove(goal.indexOf("A on C"));
                    goal.add("clear C");
                }
                label1.setBounds(ax,ay,48,48);
                p3.add(label1);
                p3.add(back_label);
                //debug(state);
            }
        }else if(block.equals("B")){
            if(match_list(goal,"clear B")&&match_list(goal,"handEmpty")){
                bx=25;
                by=316;
                goal.remove(goal.indexOf("handEmpty"));
                goal.add("holding B");
                if(match_list(goal,"ontable B")){
                    goal.remove(goal.indexOf("ontable B"));
                }else if(match_list(goal,"B on A")){
                    goal.remove(goal.indexOf("B on A"));
                    goal.add("clear A");
                }else if(match_list(goal,"B on C")){
                    goal.remove(goal.indexOf("B on C"));
                    goal.add("clear C");
                }
                label2.setBounds(bx,by,48,48);
                p3.add(label2);
                p3.add(back_label);
                //debug(state);
            }
        }else if(block.equals("C")){
            if(match_list(goal,"clear C")&&match_list(goal,"handEmpty")){
                cx=25;
                cy=316;
                goal.remove(goal.indexOf("handEmpty"));
                goal.add("holding C");
                if(match_list(goal,"ontable C")){
                    goal.remove(goal.indexOf("ontable C"));
                }else if(match_list(goal,"C on A")){
                    goal.remove(goal.indexOf("C on A"));
                    goal.add("clear A");
                }else if(match_list(goal,"C on B")){
                    goal.remove(goal.indexOf("C on B"));
                    goal.add("clear B");
                }
                label3.setBounds(cx,cy,48,48);
                p3.add(label3);
                p3.add(back_label);
                //debug(state);
            }
        }
    }
    //持っているブロックをtableに置く
    void put(){
        if(match_list(goal,"holding A")){
            ax=48;
            ay=240;
            goal.remove(goal.indexOf("holding A"));
            goal.add("ontable A");
            goal.add("handEmpty");
            label1.setBounds(ax,ay,48,48);
            p3.add(label1);
            p3.add(back_label);
            //debug(state);
        }else if(match_list(goal,"holding B")){
            bx=144;
            by=240;
            goal.remove(goal.indexOf("holding B"));
            goal.add("ontable B");
            goal.add("handEmpty");
            label2.setBounds(bx,by,48,48);
            p3.add(label2);
            p3.add(back_label);
            //debug(state);
        }else if(match_list(goal,"holding C")){
            cx=240;
            cy=240;
            goal.remove(goal.indexOf("holding C"));
            goal.add("ontable C");
            goal.add("handEmpty");
            label3.setBounds(cx,cy,48,48);
            p3.add(label3);
            p3.add(back_label);
            //debug(state);
        }
    }
 
 
    class MyMouseListener extends MouseAdapter{
        int dx;
        int dy;
        int sx1,sx2,sx3;
        int sy1,sy2,sy3;
 
        JLabel label;
 
        MyMouseListener(JLabel a){
            label = a;
        }
 
        public void mouseDragged(MouseEvent e) {
            // マウスの座標から画像(ラベル)の左上の座標を取得する
            int x = e.getXOnScreen() - dx;
            int y = e.getYOnScreen() - dy;
            //デバッグ用
            System.out.println("x="+x);
            System.out.println("y="+y);
 
            //当たり判定          
            //画面外や地面の外に出ないための処理※holdingに行かない
            if(x < 0)
                x = 0;
            if(x > 328)
                x = 328;
            if(y < 0)
                y = 0;
            if(y > 240)
                y = 240;
 
            //持っているのがAであるとき
            if(x == ax && y == ay){
                if(x <= bx && bx <= x + 48 && y <= by && by <= y + 48 ){
                    x = bx;
                    y = by;
                }
                     
                ax = x;
                ay = y;
            }
 
            //持っているのがBであるとき
            if(label.getX() == bx && label.getY() == by){
                sx1 = Math.abs(label.getX() - label1.getX());
                sy1 = Math.abs(label.getY() - label1.getY());
                sx3 = Math.abs(label.getX() - label3.getX());
                sy3 = Math.abs(label.getY() - label3.getY());
                if(sx1 < 48 && sy1 <48){
                    x = ax;
                    y = ay-48;
                }
                if(sx3 < 48 && sy3 < 48){
                    x = cx;
                    y = cy-48;
                }
                bx = x;
                by = y;
            }
 
            //持っているのがCであるとき
            if(label.getX() == cx && label.getY() == cy){
                sx1 = Math.abs(label.getX() - label1.getX());
                sy1 = Math.abs(label.getY() - label1.getY());
                sx2 = Math.abs(label.getX() - label2.getX());
                sy2 = Math.abs(label.getY() - label2.getY());
                if(sx1 < 48 && sy1 <48){
                    x = ax;
                    y = ay-48;
                }
                if(sx2 < 48 && sy2 < 48){
                    x = bx;
                    y = by-48;
                }
                cx = x;
                cy = y;
            }
 
            label.setLocation(x, y);
        }
         
        public void mousePressed(MouseEvent e) {
            // 画面上でマウスで押した絶対座標からラベルの左上の座標の差を取って相対座標にする
            dx = e.getXOnScreen() - label.getX();
            dy= e.getYOnScreen() - label.getY();
        }
         
    }
 
    void goalread(){
        for(int i = 0; i < goal.size(); i++){
            //System.out.println("**********"+state.get(i)+"************");
            if(goal.get(i).equals("ontable A")){
                ax = 48;
                ay = 240;
            }
            else if(goal.get(i).equals("ontable B")){
                bx = 144;
                by = 240;
            }
            else if(goal.get(i).equals("ontable C")){
                cx = 240;
                cy = 240;
            }
            else if(goal.get(i).equals("holding A")){
                ax = 25;
                ay = 316;
            }
            else if(goal.get(i).equals("holding B")){
                bx = 25;
                by = 316;
            }
            else if(goal.get(i).equals("holding C")){
                cx = 25;
                cy = 316;
            }
            else if(goal.get(i).equals("B on A")){
                bx = ax;
                by = ay - 48;
            }
            else if(goal.get(i).equals("C on A")){
                cx = ax;
                cy = ay - 48;
            }
            else if(goal.get(i).equals("A on B")){
                ax = bx;
                ay = by - 48;
            }
            else if(goal.get(i).equals("C on B")){
                cx = bx;
                cy = by - 48;
            }
            else if(goal.get(i).equals("A on C")){
                ax = cx;
                ay = cy - 48;
            }
            else if(goal.get(i).equals("B on C")){
                bx = cx;
                by = cy - 48;
            }
        }
        label1.setBounds(ax,ay,48,48);
        label2.setBounds(bx,by,48,48);
        label3.setBounds(cx,cy,48,48);
 
    }
</pre>
 
<h3>実行例</h3>
初期状態設定画面、目標状態設定画面、プランを実行する画面をそれぞれ載せる。<br>
初期状態<br>
<img src="./GUI1.png"/>
<br>
目標状態<br>
<img src="./GUI2.png"/>
<br>
メイン<br>
<img src="./GUI3.png"/>
<img src="./GUI4.png"/>
<br>
<h2>考察</h2>
今回はGUIの方は比較的楽な分担であったが逆にほかの作業の分担が重くなってしまった<br>
しかし各々必要なものをmainに直接書き込むのではなくメソッドにして分割することによって<br>
作業をうまく分担することができたように思えた<br>
今回の改善点としてはPlanner一つのソースコードにGUIも含め全てを書き込んだため<br>
非常に冗長なソースコードになってしまったことである<br>
せめてGUIの部分はGUI.javaなどの別のソースコードを作った方が読みやすかったように思えた<br>
<br>
今回うまくいった点としては比較的早めに作業が終わったのでクオリティアップに<br>
時間を割けたことであると思われる<br>
実装できなかった機能もあるが全体的にバグも少なく安定して起動できていたので<br>
その点は良かったと思われる<br>
<br>

<hr>

<h2>感想</h2>
今回は比較的自分以外は均等なタスク配分であったと思う<br>
今回の課題は次回の発表の時の基盤となるものなのでクオリティが高いものに<br>
仕上がったのは満足である<br>
<br>
次回以降も早め早めに課題を進めクオリティを高いものにできたらいいと思う<br>
<h2>参考文献</h2>
<!-- 参考文献を書く．助けてもらった人がいれば，それも書く-->

<ul>
  <li><a href="http://www.javadrive.jp/tutorial/">Swingを使ってみよう - Java GUIプログラミング</a></li>
  <li>新谷虎松 著（2011）『改訂 Java による知能プログラミング入門』コロナ社</li>
</ul>

</body>
</html>
